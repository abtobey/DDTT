<!DOCTYPE html>

<html lang="en">
    <head>
        <!-- Required meta tags -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        
        <!-- documentation at http://getbootstrap.com/docs/4.1/, alternative themes at https://bootswatch.com/ -->
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
        <link href="styles.css" rel="stylesheet">
        <title>
        Simulation
        </title>
        <script>
        //get this variable from input
        var lineLength= 64;
        //this way the numbering system works with >100 chute per line, other wise there would be chutes with the same numbers. IRL the numbering system is different for every sorter but I'm not gonna program that in.
        var chuteNum=1;
        if(lineLength > 100){
            chuteNum=10;
        }
        //placeholder value if input box left blank
        var inductors =5;
        
        //get this variable from input
        var sweepSpeed=200;

        var trayCount=lineLength * 2 + 200;
        //PPH of 1800 corresponds to an inductSpeed variable of 7. 
        var inductSpeed=6;


        //default value is traycount because 0 is a position on the sorter, positions go from 0 - trayCount -1 so trayCount is first unused number
        const traysInner = new Array(trayCount).fill(trayCount);
        const recircInner = new Array(trayCount).fill(0);
        const traysOuter = new Array(trayCount).fill(trayCount);
        const recircOuter = new Array(trayCount).fill(0);
        
        //placeholder value for if input box left blank
        var noRead=0.05;

        var reject = lineLength -3;    
        var nrChute = lineLength -1;  
        var reject2 = lineLength * 2 + 97;
        var nrChute2 = lineLength * 2 + 99;      
        var j;
        var chute=0;
        var line=0;
        var txt="";
        var side = "";
        var bags=1;
        var pieceCount=0;
        var trayPos=0;
        var openTray=0;
        var PPH=0;
        var nrPieceCount=0;
        var swept = "";
        var assigned=0;
        var totalScans=0;
        var bagCount=0;
        var derates=0;
        var maxRecirc=0;
        var PPHtotal=0;
        var deratesTotal=0;
        var nrTotal=0;
        var maxRecircTotal=0;
        var bagCountTotal=0;
        var minutesElapsed=0;
        var sortSpan=60;
        var sorterType=0;
        var totalInductors=0;
        var CDsweep;
        


        function addRow(minute){
            minutesElapsed=minute;
            var stats= document.getElementById("stats");
            var row=stats.insertRow(stats.rows.length-1);
            var c1=row.insertCell(0);
            c1.innerHTML=minute;
            var c2=row.insertCell(1);
            c2.innerHTML=(PPH + derates);
            var c3=row.insertCell(2);
            c3.innerHTML=(PPH);
            PPHtotal += PPH;
            var c4=row.insertCell(3);
            c4.innerHTML=(PPH * 60);
            PPH=0;
            var c5=row.insertCell(4);
            c5.innerHTML=(derates);
            deratesTotal+= derates;
            derates=0;
            var c6=row.insertCell(5);
            c6.innerHTML=(nrPieceCount);
            nrTotal += nrPieceCount;
            nrPieceCount=0;
            var c7=row.insertCell(6);
            c7.innerHTML=(maxRecirc);
            maxRecircTotal += maxRecirc;
            maxRecirc=0;
            var c8=row.insertCell(7);
            c8.innerHTML=(bagCount);
            bagCountTotal += bagCount;
            bagCount=0;

        }
        function updateTotals(){
            var stats= document.getElementById("stats");
            var footer = stats.rows.length-1;
            stats.rows[footer].cells[1].innerHTML= PPHtotal + deratesTotal;
            stats.rows[footer].cells[2].innerHTML= PPHtotal;
            stats.rows[footer].cells[3].innerHTML= Math.floor(PPHtotal * 60/minutesElapsed);
            stats.rows[footer].cells[4].innerHTML= deratesTotal;
            stats.rows[footer].cells[5].innerHTML= nrTotal;
            stats.rows[footer].cells[6].innerHTML= maxRecircTotal;
            stats.rows[footer].cells[7].innerHTML= bagCountTotal;
        }
        function assign()
        {
            //a pre determined percentage of pieces will no read and go to a reject chute, this randomly assigns those. The range of chutes which can be assigned depends on the sorter type
            if (sorterType==0){
                if(Math.random() < noRead){
                    nrPieceCount ++;
                    return nrChute;
                }
                else{
                    assigned= Math.floor(Math.random() * (lineLength *2-4));
                    if(assigned >= lineLength - 4)
                    {
                        assigned += 104;
                    }
                    return assigned;
                }
            }else if (sorterType==1){
                if(Math.random() < noRead){
                    nrPieceCount ++;
                    return nrChute;
                }
                else{
                    assigned= Math.floor(Math.random() * ((lineLength -4)*2));
                    if(assigned >= lineLength - 4)
                    {
                        assigned += 104;
                    }
                    return assigned;
                }
            }
            else if (sorterType==2){
                if(Math.random() < noRead){
                    nrPieceCount ++;
                    return nrChute;
                }
                else{
                    assigned= Math.floor(Math.random() * (lineLength -4));
                    return assigned;
                }
            }
        }

        function moveTrays()
        {
            //get these variable from inputs
            if(document.getElementById("inductorsPerPlatform").value !=""){
                inductors =parseInt(document.getElementById("inductorsPerPlatform").value);
            }
                        
            switch(document.getElementById("sorterType").value){
            case "Two induct platforms":
                sorterType=0;
                totalInductors=inductors;
                CDsweep=lineLength;
                break;
            case "Four induct platforms with flow splitters":
                sorterType=1;
                totalInductors=inductors*2;
                CDsweep=lineLength-4;
                break;
            case "Four induct platforms with direct feeds":
                sorterType=2;
                totalInductors=inductors*2;
                CDsweep=lineLength-4;
                break;
            }
            const canInductIn= new Array(totalInductors).fill(0);
            const canInductOut= new Array(totalInductors).fill(0);
            if(document.getElementById("nrPercent").value !=""){
                noRead =parseFloat(document.getElementById("nrPercent").value)/100;
            }
            else{
                noRead=0.05;
            }
            
            var intCheck=parseInt(document.getElementById("sweepersPerLine").value);
            if(Number.isInteger(intCheck)){
                var sweepers=intCheck;
                document.getElementById("test").innerHTML=sweepers;
            }
            //default value is 2 
            else{
            var sweepers=2;
            document.getElementById("test").innerHTML="incorrect value entered for number of sweepers" + noRead + " " + sorterType + " " + document.getElementById("sorterType").value;}
            
            const CanSweepIn= new Array(sweepers * 2).fill(0);
            const currentLocIn= new Array(sweepers * 2).fill(0);
            const sweeperPosIn = new Array(sweepers * 2).fill(0);
            const CanSweepOut= new Array(sweepers * 2).fill(0);
            const currentLocOut= new Array(sweepers * 2).fill(0);
            const sweeperPosOut = new Array(sweepers * 2).fill(0);
            var separation= Math.floor(lineLength/sweepers);
            for(i=0; i< sweepers; i++)
            {
                currentLocIn[i]= separation* i;
                currentLocOut[i]= separation* i;
            }
            for(i=sweepers; i< sweepers * 2; i++)
            {
                currentLocIn[i]= separation* (i - sweepers);
                currentLocOut[i]= separation* (i - sweepers);
            }
            //get span
            if(document.getElementById("sortSpan").value !=""){
                sortSpan =parseInt(document.getElementById("sortSpan").value);
            }
            
            //each time j increments is the amount of time for the sorter to move one tray length= approx. .25 seconds
            for (j=0; j<=214*sortSpan; j++)
            {
                //add row to table every minute
                if(j % 214==0 && j > 0){
                    addRow(j/214);
                }

                //tells me if the loop started
                trayPos -=1;
                //moves trays forward, resets when it gets to end of loop
                if(trayPos < 0){
                    trayPos=trayCount;
                }
                //sweepers: it takes about 50 seconds or 200 increments to sweep a bag, but this value can be adjusted
                //B Line
                for(k=0; k< sweepers; k++)
                {
                    if(CanSweepIn[k] > 0)
                    {
                        CanSweepIn[k] -= 1;
                    }
                    else
                    {
                        for(m=0; m< lineLength -4; m++)
                        {
                            if(CanSweepIn[k] ==0)
                            {
                                if(currentLocIn[k] + m < lineLength -4)
                                {
                                    if(document.getElementById("toprows").rows[2].cells[currentLocIn[k] + m].innerHTML >= 35)
                                    {
                                        document.getElementById("toprows").rows[2].cells[currentLocIn[k] + m].innerHTML =0;
                                        document.getElementById("toprows").rows[2].cells[currentLocIn[k] + m].style.backgroundColor="white";
                                        CanSweepIn[k] =sweepSpeed;
                                        swept= swept + " " +(currentLocIn[k] + m) + "sweeper # " + k;
                                        bagCount++;
                                    }
                                }
                                else if(currentLocIn[k] - m >= 0)
                                {
                                     if(document.getElementById("toprows").rows[2].cells[currentLocIn[k] - m].innerHTML >= 35)
                                    {
                                        document.getElementById("toprows").rows[2].cells[currentLocIn[k] - m].innerHTML =0;
                                        document.getElementById("toprows").rows[2].cells[currentLocIn[k] - m].style.backgroundColor="white";
                                        CanSweepIn[k] =sweepSpeed;
                                        swept= swept + " " +(currentLocIn[k] + m);
                                        bagCount++;
                                    }
                                }
                            }
                        }
                    }
                }
                //this is not ideal but just getting it to work
                //C Line
                for(k=sweepers; k< sweepers *2; k++)
                {
                    if(CanSweepIn[k] > 0)
                    {
                        CanSweepIn[k] -= 1;
                    }
                    else
                    {
                        //CDsweep variable is the amount of chutes the sweepers will use on the lower lines. For a 2 induct setup, the whole line is used, otherwise the last 4 are rejects and the sweepers don't sweep those
                        for(m=0; m< CDsweep; m++)
                        {
                            if(CanSweepIn[k] ==0)
                            {
                                if(currentLocIn[k] + m < CDsweep)
                                {
                                    if(document.getElementById("bottomrows").rows[1].cells[currentLocIn[k] + m].innerHTML >= 35)
                                    {
                                        document.getElementById("bottomrows").rows[1].cells[currentLocIn[k] + m].innerHTML =0;
                                        document.getElementById("bottomrows").rows[1].cells[currentLocIn[k] + m].style.backgroundColor ="white";
                                        CanSweepIn[k] =sweepSpeed;
                                        bagCount++;
                                    }
                                }
                                else if(currentLocIn[k] - m >= 0)
                                {
                                     if(document.getElementById("bottomrows").rows[1].cells[currentLocIn[k] - m].innerHTML >= 35)
                                    {
                                        document.getElementById("bottomrows").rows[1].cells[currentLocIn[k] - m].innerHTML =0;
                                        document.getElementById("bottomrows").rows[1].cells[currentLocIn[k] - m].style.backgroundColor = "white";
                                        CanSweepIn[k] =sweepSpeed;
                                        bagCount++;
                                    }
                                }
                            }
                        }
                    }
                }
                //A Line
                for(k=0; k< sweepers; k++)
                {
                    if(CanSweepOut[k] > 0)
                    {
                        CanSweepOut[k] -= 1;
                    }
                    else
                    {
                        for(m=0; m< lineLength -4; m++)
                        {
                            if(CanSweepOut[k] ==0)
                            {
                                if(currentLocOut[k] + m < lineLength -4)
                                {
                                    if(document.getElementById("toprows").rows[1].cells[currentLocOut[k] + m].innerHTML >= 35)
                                    {
                                        document.getElementById("toprows").rows[1].cells[currentLocOut[k] + m].innerHTML =0;
                                        document.getElementById("toprows").rows[1].cells[currentLocOut[k] + m].style.backgroundColor = "white";
                                        CanSweepOut[k] =sweepSpeed;
                                        swept= swept + " " +(currentLocOut[k] + m);
                                        bagCount++;
                                    }
                                }
                                else if(currentLocOut[k] - m >= 0)
                                {
                                     if(document.getElementById("toprows").rows[1].cells[currentLocOut[k] - m].innerHTML >= 35)
                                    {
                                        document.getElementById("toprows").rows[1].cells[currentLocOut[k] - m].innerHTML =0;
                                        document.getElementById("toprows").rows[1].cells[currentLocOut[k] - m].style.backgroundColor = "white";
                                        CanSweepOut[k] =sweepSpeed;
                                        swept= swept + " " +(currentLocOut[k] + m);
                                        bagCount++;
                                    }
                                }
                            }
                        }
                    }
                }
                //D Line
                for(k=sweepers; k< sweepers *2; k++)
                {
                    if(CanSweepOut[k] > 0)
                    {
                        CanSweepOut[k] -= 1;
                    }
                    else
                    {
                        for(m=0; m< CDsweep; m++)
                        {
                            if(CanSweepOut[k] ==0)
                            {
                                if(currentLocOut[k] + m < CDsweep)
                                {
                                    if(document.getElementById("bottomrows").rows[2].cells[currentLocOut[k] + m].innerHTML >= 35)
                                    {
                                        document.getElementById("bottomrows").rows[2].cells[currentLocOut[k] + m].innerHTML =0;
                                        document.getElementById("bottomrows").rows[2].cells[currentLocOut[k] + m].style.backgroundColor="white";
                                        CanSweepOut[k] =sweepSpeed;
                                        bagCount++;
                                    }
                                }
                                else if(currentLocOut[k] - m >= 0)
                                {
                                     if(document.getElementById("bottomrows").rows[2].cells[currentLocOut[k] - m].innerHTML >= 35)
                                    {
                                        document.getElementById("bottomrows").rows[2].cells[currentLocOut[k] - m].innerHTML =0;
                                        document.getElementById("bottomrows").rows[2].cells[currentLocOut[k] - m].style.backgroundColor="white";
                                        CanSweepOut[k] =sweepSpeed;
                                        bagCount++;
                                    }
                                }
                            }
                        }
                    }
                }
                //each inductor can run at PPH of about 1500, meaning if constant speed and all trays empty, they fill every 8th tray
                for(k=0; k<inductors; k++)
                {
                    //if tray open and inductor ready then fill tray
                    if(canInductIn[k]==0)
                    {
                        openTray=(lineLength + 2* k + trayPos) % trayCount;
                        if(traysInner[openTray] ==trayCount)
                        {
                            traysInner[openTray] = assign();
                        }
                        //induct speed set to 6 by default, that = 1800 PPH
                        canInductIn[k]=inductSpeed;
                    }
                    else{
                        canInductIn[k] -=1;
                    }
                    //second set of inducts for if sorter has 4 platforms (all options except 0)
                    if(sorterType !=0)
                    {
                        if(canInductIn[k + inductors]==0)
                        {
                            openTray=(lineLength *2 + 2* k + trayPos +100) % trayCount;
                            if(traysInner[openTray] ==trayCount)
                            {
                            //number passed to assign is either a 0 or 1, 0 is first inducto platform, 1 is second platform if 4 platforms selected
                                traysInner[openTray] = assign() + 100 + lineLength;
                            }
                            //induct speed set to 6 by default, that = 1800 PPH
                            canInductIn[k+ inductors]=inductSpeed;
                        }
                        else{
                            canInductIn[k + inductors] -=1;
                        }
                    }
                    //Repeat for Outer Loop
                    if(canInductOut[k]==0)
                    {
                        openTray=(lineLength + 2* k + trayPos) % trayCount;
                        if(traysOuter[openTray] ==trayCount)
                        {
                            traysOuter[openTray] = assign();
                        }
                        //induct speed set to 6 by default, that = 1800 PPH
                        canInductOut[k]=inductSpeed;
                    }
                    else{
                        canInductOut[k] -=1;
                    }
                    if(sorterType !=0)
                    {
                        if(canInductOut[k + inductors]==0)
                        {
                            openTray=(lineLength *2 + 2* k + trayPos +100) % trayCount;
                            if(traysOuter[openTray] ==trayCount)
                            {
                            //number passed to assign is either a 0 or 1, 0 is first inducto platform, 1 is second platform if 4 platforms selected
                                traysOuter[openTray] = assign() + 100 + lineLength;
                            }
                            //induct speed set to 6 by default, that = 1800 PPH
                            canInductOut[k+ inductors]=inductSpeed;
                        }
                        else{
                            canInductOut[k + inductors] -=1;
                        }
                    }
                }
                //loop through trays to see if position matches up with destination of piece
                for(k=0; k<trayCount; k++)
                {
                    if((k + trayPos) % trayCount == traysInner[k]){
                        if (traysInner[k] < lineLength){
                            side="toprows";
                            line=2;
                            chute=traysInner[k];
                        }
                        //100 tray buffer between sides, must subtract 100 if on bottom side
                        else{
                            side="bottomrows";
                            line=1;
                            chute=traysInner[k] -(100 + lineLength);
                        }
                        //if < 35 pieces in the bag, it can drop the piece, otherwise chute is full and piece recircs
                        pieceCount=parseInt(document.getElementById(side).rows[line].cells[chute].innerHTML);
                        if(pieceCount < 35 && traysInner[k] != reject && traysInner[k] != nrChute && traysInner[k] != reject2 && traysInner[k] != nrChute2){
                            pieceCount ++;
                            document.getElementById(side).rows[line].cells[chute].innerHTML = pieceCount;
                            if(pieceCount== 35){
                                document.getElementById(side).rows[line].cells[chute].style.backgroundColor = "purple";
                            }
                            traysInner[k] =trayCount;
                            recircInner[k] =0;
                            PPH++;
                        }
                        //reject is the chute that catches max recirc pieces. The logic of a parcel sorter is that it tries to drop a piece 3 times and if chute is full 3 times in a row, it goes to max recirc bin
                        else if(traysInner[k]== reject){
                            document.getElementById(side).rows[line].cells[chute].innerHTML = pieceCount + 1;
                            traysInner[k] =trayCount;
                            recircInner[k] =0;
                            maxRecirc++;
                        }
                        else if(traysInner[k] == nrChute || traysInner[k]==nrChute2){
                            document.getElementById(side).rows[line].cells[chute].innerHTML = pieceCount + 1;
                            traysInner[k] =trayCount;
                            recircInner[k] =0;
                        }
                        else{
                            recircInner[k] ++;
                            derates++;
                            if (recircInner[k] ==3){
                                traysInner[k]=reject;
                            }
                        }
                    }
                    if((k + trayPos) % trayCount == traysOuter[k]){
                        if (traysOuter[k] < lineLength){
                            side="toprows";
                            line=1;
                            chute=traysOuter[k];
                        }
                        //100 tray buffer between sides, must subtract 100 if on bottom side
                        else{
                            side="bottomrows";
                            line=2;
                            chute=traysOuter[k] -(100 + lineLength);
                        }
                        //if < 35 pieces in the bag, it can drop the piece, otherwise chute is full and piece recircs
                        pieceCount=parseInt(document.getElementById(side).rows[line].cells[chute].innerHTML);
                        if(pieceCount < 35 && traysOuter[k] != reject && traysOuter[k] != nrChute && traysOuter[k] != reject2 && traysOuter[k] != nrChute2){
                            pieceCount ++;
                            document.getElementById(side).rows[line].cells[chute].innerHTML = pieceCount;
                            if(pieceCount== 35){
                                document.getElementById(side).rows[line].cells[chute].style.backgroundColor = "purple";
                            }
                            traysOuter[k] =trayCount;
                            recircInner[k] =0;
                            PPH++;
                        }
                        //reject is the chute that catches max recirc pieces. The logic of a parcel sorter is that it tries to drop a piece 3 times and if chute is full 3 times in a row, it goes to max recirc bin
                        else if(traysOuter[k]== reject){
                            document.getElementById(side).rows[line].cells[chute].innerHTML = pieceCount + 1;
                            traysOuter[k] =trayCount;
                            recircOuter[k] =0;
                            maxRecirc++;
                        }
                        else if(traysOuter[k] == nrChute || traysOuter[k] == nrChute2){
                            document.getElementById(side).rows[line].cells[chute].innerHTML = pieceCount + 1;
                            traysOuter[k] =trayCount;
                            recircOuter[k] =0;
                        }
                        else{
                            recircOuter[k] ++;
                            derates++;
                            if (recircOuter[k] ==3){
                                traysOuter[k]=reject;
                            }
                        }
                    }
                }

            }
            updateTotals();
        }
        </script>
    </head>
    <body>
        <div class="jumbotron jumbotron-fluid">
            <div class="container">
              <h1 class="display-4">Dual Density Tilt Tray Sorter Simulation</h1>
              <p class="lead">This is a simulation of a dual density tilt tray sorter performing under the chosen parameters.</p>
            </div>
          </div>
          <p id="test">Default values will be used if inputs left blank or non-integer entered.</p>
          <div class="form-row">
          <div class="col-md-3">
            <!-- Material input -->
            <div class="md-form form-group">
              <label for="sortSpan">Simulation Span (minutes)</label>
              <input type="number" class="form-control" id="sortSpan" min="1" placeholder="60">
              
            </div>
          </div>
        </div>
          <div class="form-row">
            <div class="col-md-3">
              <!-- Material input -->
              <div class="md-form form-group">
                <label for="sweepersPerLine">Sweepers per Line (Sweeper PPH = 50 sacks/hr)</label>
                <input type="number" class="form-control" id="sweepersPerLine" min="1" placeholder="2">
                
              </div>
            </div>
            <div class="col-md-3">
                <!-- Material input -->
                <div class="md-form form-group">
                  <label for="inductorsPerPlatform">Inductors per platform per side (Base PPH=1800)</label>
                  <input type="number" class="form-control" id="inductorsPerPlatform" min="1" placeholder="5">
                  
                </div>
              </div>
            </div>
            <div class="form-row">
              <div class="col-md-3">
                <!-- Material input -->
                <div class="md-form form-group">
                  <label for="nrPercent">No read percentage (do not enter % sign) </label>
                  <input type="number" class="form-control" id="nrPercent" min="1" placeholder="5.0">
                </div>
              </div>
              
                <div class="col-md-3">
                <label for="sorterType">Sorter Layout</label>
                <select class="form-control" id="sorterType">
                  <option>Two induct platforms</option>
                  <option>Four induct platforms with flow splitters</option>
                  <option>Four induct platforms with direct feeds</option>
                </select>
                </div>
                
              </div>
            </div>


        <table id="toprows" style="width:80%">
            <thead>
                <tr id="ALineNumbers">
                    <script>
                        aLine=document.getElementById("ALineNumbers");
                        for(i=0; i< lineLength; i++)
                        {
                            td = aLine.appendChild(document.createElement('td'));
                            td.innerHTML =(100 * chuteNum) + lineLength -i;
                        }                   
                    </script>
                </tr>
            </thead>
            <tr id="row1">
            <script>
                //setting up display for rows
                row1=document.getElementById("row1");
                for(i=0; i< lineLength; i++)
                {
                    td = row1.appendChild(document.createElement('td'));
                    td.innerHTML =0;
                }
            </script>
            </tr>
            <tr id="row2">
            <script>
                row2=document.getElementById("row2");
                for(i=0; i< lineLength; i++)
                {
                    td = row2.appendChild(document.createElement('td'));
                    td.innerHTML =0;
                }
            </script>
            </tr>
            <tfoot>
                <tr id="BLineNumbers">
                    <script>
                        bLine=document.getElementById("BLineNumbers");
                        for(i=0; i< lineLength; i++)
                        {
                            td = bLine.appendChild(document.createElement('td'));
                            td.innerHTML =(200 * chuteNum) + lineLength -i;
                        }                   
                    </script>
                </tr>
            </tfoot>
            </table>
            <br>
            <br>
            <table id ="bottomrows" style="width:80%">
                <thead>
                    <tr id="CLineNumbers">
                        <script>
                            cLine=document.getElementById("CLineNumbers");
                            for(i=0; i< lineLength; i++)
                            {
                                td = cLine.appendChild(document.createElement('td'));
                                td.innerHTML =i + 1 + (300*chuteNum);
                            }                   
                        </script>
                    </tr>
                </thead>
            <tr id = "row3">
            <script>
                row3=document.getElementById("row3");
                for(i=0; i< lineLength; i++)
                {
                    td = row3.appendChild(document.createElement('td'));
                    td.innerHTML =0;
                }
            </script>
            </tr>
            <tr id = "row4">
            <script>
                row4=document.getElementById("row4");
                for(i=0; i< lineLength; i++)
                {
                    td = row4.appendChild(document.createElement('td'));
                    td.innerHTML =0;
                }
            </script>
            </tr>
            <tfoot>
                <tr id="DLineNumbers">
                    <script>
                        dLine=document.getElementById("DLineNumbers");
                        for(i=0; i< lineLength; i++)
                        {
                            td = dLine.appendChild(document.createElement('td'));
                            td.innerHTML =i + 1 +400 * chuteNum;
                        }                   
                    </script>
                </tr>
            </tfoot>
            </table>
            <br><br>
            <button class="btn btn-primary", onclick="moveTrays()">Start Simulation</button>
            
        <table id="stats" style="width:40%">
            <thead>
                <tr>
                    <th>Minute</th>
                    <th>Scans</th>
                    <th>Sorted</th>
                    <th>PPH</th>
                    <th>Derates</th>
                    <th>No Reads</th>
                    <th>Max Recirc</th>
                    <th>Bags Completed</th>
                </tr>
            </thead>
            <tfoot>
                <tr>
                    <th>Total</th>
                    <th>0</th>
                    <th>0</th>
                    <th>0</th>
                    <th>0</th>
                    <th>0</th>
                    <th>0</th>
                    <th>0</th>
                </tr>
            </tfoot>
        </table>
        <script type="text/javascript" src="javascript.js"></script>
        <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>
    </body>
</html>